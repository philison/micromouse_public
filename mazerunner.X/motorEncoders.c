
#include <xc.h>
//#include "gpio.h"
#include "motorEncoders.h"
//file global



 long rotationCount1;
 long rotationCount2;
//long currentEncoderPosition;

#include <math.h>

//****************************************************************INITIALISE QEI************************

void initQEI1( unsigned int  startPos)
{


    QEI1CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI1CONbits.QEIM = 0b111;// Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI1CONbits.SWPAB = 0; // Phase A and B not swapped
    QEI1CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI1CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI1CONbits.POSRES = 0; // index does not reset position counter
    QEI1CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI1CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAXCNT = 0xffff;
  
    POSCNT =  startPos;
    rotationCount1=0;

    IFS3bits.QEI1IF = 0; // clear interrupt flag
    IEC3bits.QEI1IE = 1; // enable interrupt
    IPC14bits.QEI1IP = 5;
}

void initQEI2( unsigned int  startPos)
{


    QEI2CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI2CONbits.QEIM = 0b111;// Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI2CONbits.SWPAB = 1; // Phase A and B  swapped
    QEI2CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI2CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI2CONbits.POSRES = 0; // index does not reset position counter
    QEI2CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI2CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAX2CNT = 0xffff;

    POS2CNT =  startPos;
    rotationCount2=0;
    IFS4bits.QEI2IF = 0; // clear interrupt flag
    IEC4bits.QEI2IE = 1; // enable interrupt
    IPC18bits.QEI2IP = 5;
}


void __attribute__((__interrupt__, auto_psv)) _QEI1Interrupt(void)
{
    // Interrupt generated by QEI roll over/under
    IFS3bits.QEI1IF = 0; // clear interrupt
    //LED1=~LED1;


    if (POSCNT < 32768)
    {
        rotationCount1=rotationCount1+ (long)  0x10000; //we had a positive roll-over
    }
    else
    {
        rotationCount1=rotationCount1- (long) 0x10000;//we had a negative roll-over
    }


}


void __attribute__((__interrupt__, auto_psv)) _QEI2Interrupt(void)
{
    // Interrupt generated by QEI roll over/under
    IFS4bits.QEI2IF = 0; // clear interrupt
    //LED1=~LED1;
    if (POS2CNT < 32768)
    {
        rotationCount2=rotationCount2+ (long)  0x10000; //we had a positive roll-over
    }
    else
    {
        rotationCount2=rotationCount2- (long) 0x10000;//we had a negative roll-over
    }





}


float getPositionInRad()
{
    long currentEncoderPosition;
        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentEncoderPosition);
        //disable interrupts to make sure we have consistent data
    _NSTDIS=0;
    return 3.141592*2*currentEncoderPosition/(16*4*33);
}

long getPositionInCounts_1()
{
        long currentEncoderPosition;
        GET_ENCODER_1 (currentEncoderPosition);
        return currentEncoderPosition; 
}

int getVelocityInCountsPerSample_1()
{
    static long oldPosition;
    long currentPosition;
    int velocity;

        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentPosition);
    _NSTDIS=0;
    velocity=(currentPosition-oldPosition);

    oldPosition=currentPosition;
    return velocity;


}


long getPositionInCounts_2()
{
        long currentEncoderPosition;
        GET_ENCODER_2 (currentEncoderPosition);
        return currentEncoderPosition; 
}

int getVelocityInCountsPerSample_2()
{
    static long oldPosition;
    long currentPosition;
    int velocity;

        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_2 (currentPosition);
    _NSTDIS=0;
    velocity=(currentPosition-oldPosition);

    oldPosition=currentPosition;
    return velocity;


}

float getVelocityInRadPerSecond()
{


    static long oldPosition;
    float velocity;
    long currentPosition;

        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentPosition);
    _NSTDIS=0;
    velocity=3.141592 *2* ((currentPosition-oldPosition) * timer_time * 1000.0) / (33*4*16);

    oldPosition=currentPosition;
    return velocity;
}

float getVelocityInRadPerSecond_Right()
{

    static long oldPosition;
    float velocity;
    long currentPosition;

        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentPosition);
    _NSTDIS=0;
    velocity=3.141592 *2* ((currentPosition-oldPosition) * timer_time * 1000.0) / (33*4*16);

    oldPosition=currentPosition;
    return velocity;

}


float getVelocityInRadPerSecond_Left()
{

    static long oldPosition;
    float velocity;
    long currentPosition;

    //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_2 (currentPosition);
    _NSTDIS=0;
    velocity=3.141592 *2* ((currentPosition-oldPosition) * timer_time * 1000.0) / (33*4*16);

    oldPosition=currentPosition;
    return velocity;

}

float getVelocityInRoundsPerSecond_Left() {
    // Calc: 1/(2*3.141592) = 0.159154
   return 0.159154 * getVelocityInRadPerSecond_Left();
}

float getVelocityInRoundsPerSecond_Right() {
    // Calc: 1/(2*3.141592) = 0.159154
   return 0.159154 * getVelocityInRadPerSecond_Right();
}

float getVelocityInRoundsPerMinutes_Left() {
   return 60 * getVelocityInRoundsPerSecond_Left();
}

float getVelocityInRoundsPerMinutes_Right() {
   return 60 * getVelocityInRoundsPerSecond_Right();
}





// float getVelocityInRoundsPerMinute_Right() {
//     static long oldPosition;
//     float velocity;
//     long currentPosition;

//     //disable interrupts to make sure we have consistent data
//     _NSTDIS=1;
//     GET_ENCODER_2 (currentPosition);
//     _NSTDIS=0;
//     float nbr_of_rounds_per_second = (currentPosition-oldPosition) / (33.0*4.0*16.0) * 1000.0;
//     velocity=60.0 * nbr_of_rounds_per_second;

//     oldPosition=currentPosition;
//     return velocity;
// }

float getFlanksPerSecond_Right() {
    static long oldFLankCount;
    float flanksPerSecond;
    long currentFLankCount;

    //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentFLankCount);
    _NSTDIS=0;

    flanksPerSecond = (currentFLankCount-oldFLankCount) * timer_time * 1000; // timer_time * 1000 = timer time in seconds

    oldFLankCount=currentFLankCount;
    return flanksPerSecond;
}

// !!! returns flanks per second
// float getRPM_Right() {
//     static long oldFLankCount;
//     float flanksPerSecond;
//     long currentFLankCount;

//     //disable interrupts to make sure we have consistent data
//     _NSTDIS=1;
//     GET_ENCODER_1 (currentFLankCount);
//     _NSTDIS=0;

//     flanksPerSecond = (currentFLankCount-oldFLankCount) * timer_time * 1000; // timer_time * 1000 = timer time in seconds

//     oldFLankCount=currentFLankCount;
//     return flanksPerSecond;
// }


// float getVelocityInDegreePerSecond_Left()
// {
//     static long oldPosition;
//     float velocity;
//     long currentPosition;

//         //disable interrupts to make sure we have consistent data
//     _NSTDIS=1;
//     GET_ENCODER_1 (currentPosition);
//     _NSTDIS=0;
//     velocity=360 *2* ((currentPosition-oldPosition)*0.01) / (33*4*16);
    
//     oldPosition=currentPosition;
//     return velocity;
// }



float getTotalDrivenDistanceInMeters()
{
    static long oldPosition;
    static float distance = 0;
    // float distance;
    long currentPosition;

    float wheel_diameter = 0.06;
    float wheel_cirumference = wheel_diameter * 3.141592;

        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentPosition);
    _NSTDIS=0;
    // distance += (currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    distance += (float)(currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    // distance = (float)(currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    // distance = (float)(currentPosition-oldPosition);
    // distance = (float)(currentPosition);

    oldPosition=currentPosition;
    return distance;
}

// Each invocation of the getDrivenDistanceInMeters function influences the next invocation of this function
// Therefore if the getDrivenDistanceInMeters function gets called from different independent functions the results of this function will be wrong
// TODO: Each function than needs to have its own getDrivenDistanceInMeters (or find another solution like a function specific key variable that is passed to the getDrivenDistanceInMeters function)
// Returns the distance since last invocation of this function
float getDrivenDistanceInMeters()
{
    static long oldPosition;
    float distance;
    // float distance;
    long currentPosition;

    float wheel_diameter = 0.06;
    float wheel_cirumference = wheel_diameter * 3.141592;

        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentPosition);
    _NSTDIS=0;
    // distance += (currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    distance = (float)(currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    // distance = (float)(currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    // distance = (float)(currentPosition-oldPosition);
    // distance = (float)(currentPosition);

    oldPosition=currentPosition;
    return distance;
}

// Each invocation of the getDrivenDistanceInMeters function influences the next invocation of this function
// Therefore if the getDrivenDistanceInMeters function gets called from different independent functions the results of this function will be wrong
// Each function than needs to have its own getDrivenDistanceInMeters (or find another solution like a function specific key variable that is passed to the getDrivenDistanceInMeters function)
float getDrivenDistanceInMeters2()
{
    static long oldPosition;
    float distance;
    // float distance;
    long currentPosition;

    float wheel_diameter = 0.06;
    float wheel_cirumference = wheel_diameter * 3.141592;

        //disable interrupts to make sure we have consistent data
    _NSTDIS=1;
    GET_ENCODER_1 (currentPosition);
    _NSTDIS=0;
    // distance += (currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    distance = (float)(currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    // distance = (float)(currentPosition-oldPosition) / (33*4*16) * wheel_cirumference;
    // distance = (float)(currentPosition-oldPosition);
    // distance = (float)(currentPosition);

    oldPosition=currentPosition;
    return distance;
}




// TODO: currently the traveled distance is only meassured on the right wheel !!!
// and not a mean between the two wheels
// float getDistanceToGoalInMeters(float initial_distance_to_goal){

//     float wheel_diameter = 0.06;
//     float wheel_cirumference = wheel_diameter * 3.141592;

//     static float distance_driven = 0;
//     static float old_position = 0;
//     float current_position = getPositionInCounts_1();
//     float distance_driven_in_counts = current_position - old_position;
//     float distance_driven_in_meters = distance_driven_in_counts / (33.0*4.0*16.0) * wheel_cirumference;
//     distance_driven += distance_driven_in_meters;
//     old_position = current_position;

//     return initial_distance_to_goal - distance_driven;
// }

// Simplified version from above
float getDistanceToGoalInMeters(float initial_distance_to_goal){

    static float distance_driven = 0;
    float distance_driven_in_meters = getDrivenDistanceInMeters();
    distance_driven += distance_driven_in_meters;

    return initial_distance_to_goal - distance_driven;
}

// Get the angle difference between the current robot angle and the goal angle
// TODO: Only the left wheel is used to calculate the angle driven !!!!
// TODO: angle_driven will not be reseted after the goal is reached !!!!
float getAngleToGoalInDegrees(float initial_angle_to_goal) {
    
    float wheel_diameter = 0.06;
    float wheel_cirumference = wheel_diameter * 3.141592;

    static float angle_driven = 0;
    static float old_position = 0;

    // Calculate distance driven
    float current_position = getPositionInCounts_2();
    float distance_driven_in_counts = current_position - old_position;
    float distance_driven_in_meters = distance_driven_in_counts / (33.0*4.0*16.0) * wheel_cirumference;
    
    // Calculate angle driven from distance of right wheel
    // a  = d * 360 / (2 * pi * r) with a = angle_driven_in_degrees and r in meters
    float angle_driven_in_degrees = distance_driven_in_meters * 3000.0 / 3.141592;
    angle_driven += angle_driven_in_degrees;    
    old_position = current_position;

    return initial_angle_to_goal - angle_driven;

    // float current_angle = getPositionInRad();
    // float angle_difference = initial_angle_to_goal - current_angle;
    // return angle_difference * 180.0 / 3.141592;
}


// float getTotalDrivenAngleInDegrees() {
    
//     float wheel_diameter = 0.06;
//     float wheel_cirumference = wheel_diameter * 3.141592;

//     static float angle_driven = 0;
//     static float old_position = 0;

//     // Calculate distance driven
//     float current_position = getPositionInCounts_2();
//     float distance_driven_in_counts = (float) current_position - old_position;
//     float distance_driven_in_meters = distance_driven_in_counts / (33.0*4.0*16.0) * wheel_cirumference;
    
//     // Calculate angle driven from distance of right wheel
//     // a  = d * 360 / (2 * pi * r) with a = angle_driven_in_degrees and r in meters
//     float angle_driven_in_degrees = distance_driven_in_meters * 3000.0 / 3.141592;
//     angle_driven += angle_driven_in_degrees;    
//     old_position = current_position;

//     // return angle_driven;
//     return distance_driven_in_meters;
// }

float getTotalDrivenAngleInDegrees() {

    static float distance = 0;

    static float angle_driven = 0;
    float distance_driven_in_meters = getDrivenDistanceInMeters2();

    // Calculate angle driven from distance of right wheel
    // a  = d * 360 / (2 * pi * r) with a = angle_driven_in_degrees and r (turn radius) in meters 
    float angle_driven_in_degrees = distance_driven_in_meters * 3000.0 / 3.141592;
    angle_driven += angle_driven_in_degrees;    

    // return angle_driven;
    // return distance_driven_in_meters;
    // distance += distance_driven_in_meters;
    return angle_driven;
}


/*
    // Calc: 1/(2*3.141592) = 0.159154
    float distance_driven_left = 0.159154 * getVelocityInRadPerSecond_Left() * timer_time * 1000.0;
    float distance_driven_right = 0.159154 * getVelocityInRadPerSecond_Right() * timer_time * 1000.0;

    distance_driven += (distance_driven_left + distance_driven_right) / 2.0;
*/